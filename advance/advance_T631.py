'''
问题描述
　　（这道题的数据和SPJ已完工，尽情来虐吧！）
　　Yaroslav喜欢算法。我们将描述一个他最喜欢的算法。
　　1.这个算法接受一个字符串作为输入。我们设这个输入字符串为a。
　　2.这个算法由一些命令组成。i号命令的形式为"s[i]>>w[i]"或"s[i]<>w[i]"，
     其中s[i]和w[i]是长度不超过7的字符串（可以为空），由数字或字符"?"组成。
　　3.这个算法每次寻找一个编号最小的命令i，使得s[i]是a的子串。
     如果没有找到这样的命令，那么整个算法终止。
　　4.设找到的命令编号为k。在字符串a中，s[k]第一次出现的位置会被w[k]替换。
     如果这个命令形如"s[k]>>w[k]"，那么这个算法继续执行（译注：回到第3步）。否则，算法终止。
　　5.算法的输出就是算法终止时字符串a的值。
　　  Yaroslav有一个n个正整数的集合，他需要一个这样的算法，且能够使每一个数加1。
     更正式地，如果我们把每个数看成一个十进制表示的字符串，
     那么对于每个字符串独立地运行这个算法，这个算法需要输出一个输入串对应的数+1的字符串。
　　帮帮他吧！
输入格式
　　第一行包含一个整数n（集合中数的个数），接下来n行，每行包含一个正整数。
输出格式
　　输出一个符合题意的算法（能够分别将每个数增加1）。第i行输出这个算法的第i个命令，不包含空格。
　　你的算法将会对于每个输入运行一遍。你的输出会被认为是正确的，当且仅当：
　　·每行都是一个合法的命令（格式见题目描述）
　　·命令的条数不能超过50。
　　·算法需要对每个给出的数+1。
　　·为了得到结果，算法必须对于每个输入都执行不超过200步。
'''

# 没太看懂题目,先马着明天早上起床看
